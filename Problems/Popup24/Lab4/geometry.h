// Authors: Marc Gr√∂ling

#ifndef geometry_h
#define geometry_h

#include <algorithm>
#include <cmath>
#include <stdexcept>
#include <type_traits>
#include <vector>

// epislon for checking if values are "close" enough to zero
const double EPSILON = 0.0000001;

template <typename T> std::pair<T, T> min_max(const T &a, const T &b)
{
    return a < b ? std::pair<T, T>{a, b} : std::pair<T, T>{b, a};
}

template <typename T> class Point
{
  public:
    static_assert(std::is_arithmetic<T>::value, "Point coordinates require a numerical type");

    T x;
    T y;

    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(const T &x, const T &y)
    {
        this->x = x;
        this->y = y;
    }

    bool operator==(const Point &other) const
    {
        return x == other.x && y == other.y;
    }

    Point operator+(const Point &other) const
    {
        return Point(x + other.x, y + other.y);
    }

    Point operator-(const Point &other) const
    {
        return Point(x - other.x, y - other.y);
    }

    Point operator*(const T &scalar) const
    {
        return Point(x * scalar, y * scalar);
    }

    Point operator/(const T &scalar) const
    {
        if (scalar == 0)
        {
            throw std::runtime_error("Division by zero encountered!");
        }
        return Point(x / scalar, y / scalar);
    }

    Point<double> copy_double() const
    {
        return Point<double>(x, y);
    }

    T dot_product(const Point &other) const
    {
        return x * other.x + y * other.y;
    }

    // calculates a point/vector that is perpendicular to this one
    Point perpendicular() const
    {
        return Point(-y, x);
    }

    T cross_product(const Point &other) const
    {
        return x * other.y - y * other.x;
    }

    double magnitude() const
    {
        return std::sqrt(std::pow(x, 2) + std::pow(y, 2));
    }

    Point<double> normalized() const
    {
        double magnitude = this->magnitude();
        return Point<double>(x / magnitude, y / magnitude);
    }

    // calculates the euclidean distance between two points
    double distance(const Point &other) const
    {
        return std::sqrt(std::pow(x - other.x, 2) + std::pow(y - other.y, 2));
    }

    // returns the angle between two vectors (assumes that the origin of both is the coordinate center) in radians
    double angle(const Point &other) const
    {
        return std::atan2(other.y - y, other.x - x);
    }

    // calculates whether the point is within the bounding box generated by s1 and s2 (they mark opposite corners)
    bool is_within(const Point &s1, const Point &s2) const
    {
        std::pair<T, T> min_max_x = min_max(s1.x, s2.x);
        std::pair<T, T> min_max_y = min_max(s1.y, s2.y);
        return min_max_x.first <= x && x <= min_max_x.second && min_max_y.first <= y && y <= min_max_y.second;
    }

    bool on_line_segment(const std::pair<Point, Point> &l) const
    {
        return std::abs((*this - l.first).cross_product(*this - l.second)) < EPSILON &&
               this->is_within(l.first, l.second);
    }
};

template <typename T>
std::vector<Point<double>> line_segment_intersection(const std::pair<Point<T>, Point<T>> &l1,
                                                     const std::pair<Point<T>, Point<T>> &l2)
{
    // case 1: line segments are on the same line and overlap each other
    if ((l1.first - l2.first).cross_product(l1.first - l2.second) == 0 &&
        (l1.second - l2.first).cross_product(l1.second - l2.second) == 0)
    {
        // check that at least one of the points is on the other line segment
        if (l1.first.on_line_segment(l2) || l1.second.on_line_segment(l2) || l2.first.on_line_segment(l1) ||
            l2.second.on_line_segment(l1))
        {
            std::vector<Point<T>> points{l1.first, l1.second, l2.first, l2.second};
            // parallel to x-axis, sort by x values
            if (l1.first.y == l1.second.y)
            {
                std::sort(points.begin(), points.end(), [](const Point<T> &a, const Point<T> &b) { return a.x < b.x; });
            }
            else
            {
                // otherwise sort by y values
                std::sort(points.begin(), points.end(), [](const Point<T> &a, const Point<T> &b) { return a.y < b.y; });
            }
            // check that the middle points aren't equal
            if (points[1] == points[2])
            {
                return {points[1].copy_double()};
            }
            return {points[1].copy_double(), points[2].copy_double()};
        }
        return {};
    }
    // case 2: line segments share a common vertex
    if (l1.first == l2.first || l1.first == l2.second)
    {
        return {l1.first.copy_double()};
    }
    if (l1.second == l2.first || l1.second == l2.second)
    {
        return {l1.second.copy_double()};
    }
    // case 3: line segments intersect at a point that is not a point of any line segment
    // check if either line is parallel to the y-axis
    if (l1.first.x == l1.second.x)
    {
        // compute slope-intercept form for line 2
        T m2 = (l2.second.y - l2.first.y) / (l2.second.x - l2.first.x);
        T b2 = l2.first.y - m2 * l2.first.x;
        Point<double> intersection_point = Point<double>(l1.first.x, m2 * l1.first.x + b2);
        if (intersection_point.on_line_segment({l1.first.copy_double(), l1.second.copy_double()}) &&
            intersection_point.on_line_segment({l2.first.copy_double(), l2.second.copy_double()}))
        {
            return {intersection_point};
        }
        return {};
    }
    if (l2.first.x == l2.second.x)
    {
        // compute slope-intercept form for line 1
        T m1 = (l1.second.y - l1.first.y) / (l1.second.x - l1.first.x);
        T b1 = l1.first.y - m1 * l1.first.x;
        Point<double> intersection_point = Point<double>(l2.first.x, m1 * l2.first.x + b1);
        if (intersection_point.on_line_segment({l1.first.copy_double(), l1.second.copy_double()}) &&
            intersection_point.on_line_segment({l2.first.copy_double(), l2.second.copy_double()}))
        {
            return {intersection_point};
        }
        return {};
    }
    // compute slope-intercept form for both lines
    T m1 = (l1.second.y - l1.first.y) / (l1.second.x - l1.first.x);
    T m2 = (l2.second.y - l2.first.y) / (l2.second.x - l2.first.x);
    T b1 = l1.first.y - m1 * l1.first.x;
    T b2 = l2.first.y - m2 * l2.first.x;
    // compute intersection point
    double x_intersect = (double)(b2 - b1) / (m1 - m2);
    Point<double> intersection_point = Point<double>(x_intersect, m1 * x_intersect + b1);
    // check that the intersection point lies on both line segments
    if (intersection_point.on_line_segment({l1.first.copy_double(), l1.second.copy_double()}) &&
        intersection_point.on_line_segment({l2.first.copy_double(), l2.second.copy_double()}))
    {
        return {intersection_point};
    }
    return {};
}

// takes as input a closed polygon given as a vector of coordinates (x, y)
// reminder: in a closed polygon the last point equals the first one
// this method makes changes on the input vector during computation, but undoes these before returning
template <typename T> double compute_signed_area_polygon(std::vector<Point<T>> &points)
{
    double area = 0;

    if (points.size() % 2 == 0)
    {
        points.push_back(points[0]);
    }

    for (int i = 0; i < points.size() - 1; i += 2)
    {
        area += points[i + 1].x * (points[i + 2].y - points[i].y) + points[i + 1].y * (points[i].x - points[i + 2].x);
    }

    if (points.size() % 2 == 1)
    {
        points.pop_back();
    }

    return area / 2;
}

#endif